## 剑指offer 数据结构与算法

[book](https://weread.qq.com/web/reader/4e132bc07263ff664e11075ke4d32d5015e4da3b7fbb1fa).

### 1. 整数

更多的是位运算，位运算:

* 与(&)
* 或(|)
* 异或(^),相同为0，不同为1. 0^0 = 0, 1^0 = 1

左移或右移: 0001010<<2 是把0001010左移2为。

任何一个数字异或自己的结果是0，3个相同的数字，异或的结果还是自己。

### 2. 数组

常用的解法就是双指针：

* 方向相反的双指针经常用来排序数组中的两个数组之和。
* 方向相同的双指针通常用来求正数组中子数组的和或乘积。注意数组是正整数。
* 如果没有指明一定是整数的子数组求和问题，那么可以尝试从第一个数字开始累加数组中的所有
  前面若干数字之和，两个累加的和的差值对应一个子数组的数字之和。

### 3. 字符串
* 变位词和回文是比较有意思的文字游戏。
  * 如果两个字符串包含的字符及每个字符出现的次数都相同，这是变位词。一般都过哈希表来实现。
  * 回文是从前往后和从后往前，内容是一样的。一般是双指针解决。

### 3. 链表
链表的题目倒不是很难。
* 通过哨兵节点简化创建或删除链表头结点操作的代码
* 双指针
  * 前后双指针，主要用来查找链表的倒数第k个节点，先让第一个指针从链表头节点开始指向下一个节点的指针移移动k-1，然后让第2个指针，从头结点开始移动。
    这样第一个指针到达链表尾部时，第二个指针就是倒数第k个节点。
  * 快慢指针，快指针走一步，慢指针走两步，这样就可以找到链表的中间位置。或者能找到环形链表

### 4. 哈希表
哈希表的重要特点是高效，只需要O(1)的时间就可以把元素存入和取出。数组是最满足这个条件的，只要知道数组
小标，就可以用O(1)的时间存入和读出一个元素。

设计哈希表的要点：
* 使用数组来确定一个元素在哈希表的位置，元素的位置就是哈希值➗数组的长度取余数。
* 由于多个哈希值不同的元素可能放在相同的位置，那么数组的每个位置都对应一个链表。
* 为了确保链表不会太长，需要计算哈希表中元素的数目与数组的长度比值，超过阈值则需要将数组扩容。

### 5. Stack
特点
* 先入后出，最先添加的数据最后被删除。
* 为了能后入先出，插入和删除都发生在栈顶
### 6. 队列
特点
* 先入先出，最先添加的数据最先被删除。
* 队列经常被用来实现二叉树的广度优先搜索。
  * 先将根节点插入队列，然后队列取出节点，如果有子节点，则插入队列。
  * 如果要区分不同的层，则两个队列，当前层的队列和下一层的队列。遍历万当前层，再遍历下一层。
### 7. 二叉树
* 二叉树的广度优先遍历: 通过队列实现。
* 二叉树的深度优先遍历：就是前序，后序和中序遍历，采用递归或者stack实现。
* 二叉搜索树：左子节点 <= 根节点，右子节点 >= 根节点，中序遍历是解决二叉搜索树的常见思路。
  * 如果二叉搜索树有n个节点，深度为h,那么find, add, delete的time复杂度都是O(h).
  * 二叉搜索树的查找效率取决于树的高度
  * 如果平衡的二叉搜索树，，那么深度近似等于n-1, 那么time复杂度就变成O(n)
* 平衡二叉搜索树。Java提供了TreeMap, TreeSet两种结构，find, add, delete的time复杂度是O(longn)
  * TreeMap, TreeSet，适合找出>=给定值的最小值，或者<=给定值的最大值
### 8. 堆
* 最大堆: 每个节点的值>=任意子节点的值，最大堆的根节点就是整个堆的最大值
* 最小堆：每个节点的值<=任意子节点的值，最小堆的根节点是整个堆的最小值
* Java中采用PriorityQueue表示堆
* 只需要O(1)的时间，就可以知道最大值或者最小值，所以如果**面试题中求出一个动态数据集合的最大值或最小值**，则可以考虑用堆来实现。
* 最小堆用来求数据集合的K个值最大的元素，反之用最大堆
### 9. 前缀树
* 是一个树状的数据结构，存储一个所有的单词
* 主要用来解决字符串查找的问题，哈希表只能用来查找完整的字符串，如果要求根据字符串的前缀进行查找，可以用前缀树
